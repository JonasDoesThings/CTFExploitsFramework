import time
import traceback

from core.exploits.ExploitCategory import ExploitCategory
from core.logger.Logger import Logger


class Exploit:
    has_failed = False
    is_prepared = False

    start_time = -1
    time_elapsed = -1

    def __init__(self, name: str, description: str, category: ExploitCategory, subcategory: str,
                 authors=None, version=None):
        self.name = name
        self.description = description
        self.category = category
        self.subcategory = subcategory
        self.authors = authors
        self.version = version

    def prepare(self):
        try:
            Logger.info("Preparing " + self.name + "...")
            self._prepare()
        except Exception as e:
            self.failed("Failed to Prepare Exploit! (Message: " + str(e) + ")", plain=True)

        self.is_prepared = True

    def run(self):
        if not self.is_prepared:
            self.prepare()

        if self.has_failed:
            return

        print()
        Logger.info("Running " + self.name + "...")
        self.start_time = int(time.time())
        try:
            if not self._run():
                self._failed(str("Run returned false"))
        except Exception as e:
            tb = traceback.format_exc()
            Logger.error(tb)
            self._failed(str(e))

        self._after()

    def failed(self, message="Unknown", plain=False):
        self.has_failed = True

        if plain:
            Logger.warning(message)
        else:
            Logger.warning("Failed to run " + self.name + "! (Message: " + str(message) + ")")

        self._failed(message)
        self._cleanup()

    def after(self):
        self.time_elapsed = int(time.time()) - self.start_time
        Logger.success("Finished running " + self.name + " in " + str(self.time_elapsed) + " seconds!")
        self._after()
        self._cleanup()

    def _prepare(self):
        raise NotImplementedError("Should have implemented this")

    def _run(self):
        raise NotImplementedError("Should have implemented this")

    def _failed(self, message):
        pass

    def _after(self):
        raise NotImplementedError("Should have implemented this")

    def _cleanup(self):
        raise NotImplementedError("Should have implemented this")
