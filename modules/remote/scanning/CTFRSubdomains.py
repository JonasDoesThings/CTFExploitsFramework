from core.exploits.Exploit import Exploit
from core.exploits.ExploitCategory import ExploitCategory
import re
import json
import requests

from core.logger.Logger import Logger


class CTFRSubdomains(Exploit):
    target = ""

    def __init__(self):
        # Exploit Name, Exploit Description, Exploit Target Category
        super().__init__("ctfr-subdomains", "Uses certificate transparency logs for getting HTTPS websites subdomains",
                         ExploitCategory.remote, "scanning/subdomains", authors="UnaPibaGeek, Kadse")

    # Prepare stuff
    def _prepare(self):
        if self.args.target is None:
            self.failed("You need to specify a target with --target <target> !")

        self.target = re.sub('.*www\.', '', self.args.target, 1).split('/')[0].strip()

    # Do Stuff
    def _run(self):
        subdomains = []

        Logger.info("Gathering subdomains for " + str(self.target) + "...")
        r = requests.get("https://crt.sh/?q=%.{d}&output=json".format(d=self.target))

        if r.status_code != 200:
            self.failed("Failed to retrieve information from crt.sh (" + req.status_code + ")")
            return

        json_data = json.loads('[{}]'.format(r.text.replace('}{', '},{')))
        for (key, value) in enumerate(json_data):
            subdomains.append(value['name_value'])

        # Delete duplicates
        subdomains = sorted(set(subdomains))

        print()
        Logger.info("Found " + str(len(subdomains)) + " subdomains for domain " + self.target)

        for subdomain in subdomains:
            Logger.info(subdomain)

    # Gets called after the exploit got executed
    def _after(self):
        pass

    # Gets called if the exploit has failed
    def _failed(self, message):
        pass

    # Clean stuff up (Gets called after after())
    def _cleanup(self):
        pass
